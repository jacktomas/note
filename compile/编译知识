### 编译原理步骤：
 1. 看完SICP相关章节，用scheme写一个scheme解释器。由于scheme中的基本结构list，很容易用来构造抽象语法树，加上scheme语言动态类型的特点、以及强大的模式匹配，用scheme实现一个最基本的自举解释器，只需数十行代码（完美的支持闭包哦）。你会发现，这个解释器的几个关键分支，正好对应lambda演算的3要素，也是SICP全书反复强调的“基本单元”、“抽象”、“应用”三元素。

 2. 观摩一下Peter Norvig用数十行python代码实现一个scheme解释器：(How to Write a (Lisp) Interpreter (in Python))。于是，你开始知道怎样用主流语言实现解释器了，欢迎回到地球...Norvig也介绍了一个技法，让你的解释器能够支持尾递归。

 3. 用C/C++语言实现解释器。第一次用非GC语言实现GC语言，你必须开始认真思考内存管理的问题。建议暂时不实现赋值，这样，你的函数式语言解释器中，将总是只有新对象引用老对象，不会出现环形引用，于是可以直接使用引用计数

 4. 更快，更好。
     - 之前实现的解释器，都是基于抽象语法树的匹配，相当于OO设计模式中的visitor pattern；比起遍历语法树的同时进行解释的做法，尝试在遍历的过程中，先生成字节码并保存下来，之后只解释执行字节码？你能获得显著的性能提高。这样的预处理，是一种partial evaluation

     - 发现性能瓶颈在变量求值？你需要引入词法寻址（lexical addressing）了。这里你一步步优化的话，会发现你的环境链，被折叠成lua/C#那种主流形式.

     - 放弃引用计数，转向真正的GC？mark and sweep、copying gc、mark-compact gc、generational gc？怎样让注册到你环境中的c函数，其函数体中分配的临时GC对象，总是可达？移动gc对象时，怎样保证所有指向它的指针被修改？（尤其是栈上的指针变量）

     - 显然，一个程序并不总能写成尾递归形式，怎样才能让非尾递归程序的解释，也不栈溢出呢？Norvig介绍的技巧不够用了，你需要考虑实现CPS解释器或者进行全文CPS变换；于是栈空间被移动到堆中，栈将总是只有一帧

     - 尝试在scheme中进行一趟预处理，将library forms如let、let*、cond展开成基本形式？于是你开始意识到宏的威力，这是常见的data abstraction、functional abstraction之外的强力武器，syntactic abstraction

     - 在CPS解释器中实现call/cc？通过一趟全文CPS变换，输出不包含call/cc的普通scheme源码给你的DS解释器?

     - 如果你想做得更好，还有很多很多问题需要你思考，而解决这些问题的过程，是很能让你得到锻炼的.
<br/>
* 图灵社区 : 图书  : 两周自制脚本语言
  图灵社区 : 图书  : 自制编程语言

>
       作者：WBScan
       链接：https://www.zhihu.com/question/26760072/answer/33976699
       来源：知乎
       著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。